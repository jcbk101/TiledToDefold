/*
 * TiledToLuaSlim.js
 *
 * This extension adds the "Defold files" type to the "Export As" menu,
 * which generates Defold style tilemaps, tilesources and atlases.
 * 
 * The tile maps are generated by finding tilesets and creating individual tilemaps
 * to use tiles from the tileset.
 *
 * Copyright (c) 2022 John Charles
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */

var tiledToDefoldExport = {
    name: "Custom Lua Export",
    extension: "lua",
    write: processMap
};

let filePath = "";
let fileBaseName = "";
let count = 0;
let collection = "";
let globalMap = null;
let objectLayer = null;
const usedObjs = [];

let collectionHeader =
    "name: \"default\"\n" +
    "scale_along_z: 0\n";


//--------------------------------
//
// Main write function
//
//--------------------------------
function processMap(map, fileName) {

    // Split full filename path into the filename (without extension) and the directory
    fileBaseName = FileInfo.completeBaseName(fileName).replace(/[^a-zA-Z0-9-_]/g, "_");
    filePath = FileInfo.path(fileName) + "/";

    // Replace the ‘/’ characters in the file path for ‘\’ on Windows
    filePath = FileInfo.toNativeSeparators(filePath);

    //Find first tile layer
    let currentLayer;
    count = 0;
    globalMap = map;

    // This is important! set map file's 'Class' to you base directory.
    // IE: c:/defold/MyGame/
    // So if assets or what ever are stored in 'c:/defold/MyGame/assets/...'
    // Then '/assets/...' can be used in the file and directory structure
    fileBaseName = fileBaseName.replace(map.className, '');

    let newPath = filePath + "/";
    tiled.log(newPath + ", " + fileBaseName);

    //--------------------------------------
    //
    // Process all Tilemaps first
    //
    //--------------------------------------
    for (let j = 0; j < map.tilesets.length; j++) {

        let tilemapStr = "";
        let z = 0;
        let tileset = map.tilesets[j];
        let iHeader = false;
        let tilesourceFileData = "";
        let fName = null;
        let baseName = null;
        let fPath = null;
        let re = null;

        //-------------------------------------------
        // Tileset MUST be a single image in order 
        // to be considered a tilesource for Defold
        //-------------------------------------------
        if (tileset.image == "") {

            // Atlas creation using a collection of images. Defold uses 2048x2048 max I believe
            tilesourceFileData = processImageCollection(tileset);

            // Write tilesource file
            let tilesource = new TextFile(newPath + tileset.name + ".atlas", TextFile.WriteOnly);
            tilesource.write(tilesourceFileData);
            tilesource.commit();

            continue;
        }
        else {

            re = RegExp(globalMap.className, "ig");
            fName = tileset.image.replace(re, '');
            fPath = FileInfo.path(fileName);
            baseName = FileInfo.completeBaseName(tileset.image);

            // Tilesource data creation
            tilesourceFileData +=
                //"image: \"/main/" + fileBaseName + "/" + tileset.name + ".png\"\n" +
                "image: \"/" + fName + "\"\n" +
                "tile_width: " + tileset.tileWidth + "\n" +
                "tile_height: " + tileset.tileHeight + "\n" +
                "tile_margin: " + tileset.margin + "\n" +
                "tile_spacing: " + tileset.tileSpacing + "\n" +
                "collision: \"/" + fName + "\"\n" +
                "material_tag: \"tile\"\n" +
                "collision_groups: \"ground\"\n" +
                "extrude_borders: 4\n" +
                "inner_padding: 0\n" +
                "sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n";

            // Write tilesource file
            let tilesource = new TextFile(newPath + tileset.name + ".tilesource", TextFile.WriteOnly);
            tilesource.write(tilesourceFileData);
            tilesource.commit();
        }

        // Header showing tilesource file
        //        let tileMapFileData = "tile_set: \"/" + fPath.replace(re, '') + "/" + fileBaseName + "/" + baseName + ".tilesource\"\n";
    }


    let mapProps = getProperties(map, "");
    let luaString = "return {\n" +
        "  width = " + map.width + ",\n" +
        "  height = " + map.height + ",\n" +
        "  tileWidth = " + map.tileWidth + ",\n" +
        "  tileHeight = " + map.tileHeight + ",\n" +
        (mapProps != "" ? "  properties = {\n    " + mapProps + "\n  },\n" : "  properties = {},\n") +
        "  layers = {\n";

    //------------------------------------
    //
    // Loop through the tile layers
    //
    //------------------------------------
    for (let i = 0; i < map.layerCount; ++i) {

        currentLayer = map.layerAt(i);

        //-------------------------------------------
        // Must be a Tile layer, and hasto be visible
        //-------------------------------------------
        if (currentLayer.isTileLayer && currentLayer.visible) {

            luaString += exportTileLayer(currentLayer);
        }
        else if (currentLayer.isObjectLayer && currentLayer.visible) {

            let tempMap = null;
            let count = 0;

            while (tempMap == null && count < 10) {
                tempMap = exportObjects(currentLayer);
                count++;
            }

            tiled.log("Objects: " + ((tempMap == null) ? "null" : "good") + " after " + count + " tries.")

            if (tempMap != "") {
                luaString += tempMap;
            }

            // // Was data stored?
            // if (tempMap != "") {
            //     // Write the tilemap file
            //     let tilemapFile = new TextFile(newPath + currentLayer.name + ".lua", TextFile.WriteOnly);
            //     tilemapFile.write(tempMap);
            //     tilemapFile.commit();
            // }
        }

        luaString += "\n    }";
        if ((i + 1) < map.layerCount)
            luaString += ",  \n";
    }

    luaString += "\n  }"; // layer
    luaString += "\n}";  // return
    // Write tilesource file
    let collectionFile = new TextFile(newPath + fileBaseName + ".lua", TextFile.WriteOnly);
    collectionFile.write(luaString);
    collectionFile.commit();
}




//--------------------------------------
//
// Export image collection as an atlas
//
//--------------------------------------
function processImageCollection(tileset) {

    let stringData = "";
    let animations = "";
    let duration = 0;
    let re = RegExp(globalMap.className, "ig");

    for (let c = 0; c < tileset.tiles.length; c++) {

        let tile = tileset.tiles[c];

        if (tile == null)
            continue;

        let fName = tile.imageFileName.replace(re, '');

        //Header info
        stringData += "images {\n" +
            "  image: \"/" + fName + "\"" + "\n" +
            "  sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n" +
            "}\n";


        // Save animation data should it exist
        if (tile.animated == true) {

            animations += "animations {\n" +
                "  id: \"anim-" + c + "\"\n";

            duration = 0;

            for (let i = 0; i < tile.frames.length; i++) {
                let frame = tile.frames[i];

                let realTile = getTileOfId(tileset.tiles, frame.tileId);

                if (realTile != null) {
                    // Add all durations together
                    duration += frame.duration;

                    animations += "  images {\n" +
                        "    image: \"/" + realTile.imageFileName + "\"" + "\n" +
                        "    sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n" +
                        "  }\n";
                }
            }

            // Calcution an average of time per frame. 'Duration / frames' = based milliseconds for fps calculation
            //  fps = (1000 / Duration_base)
            duration /= tile.frames.length;

            animations += "  playback: PLAYBACK_LOOP_FORWARD\n" +
                "  fps: " + (1000 / duration) + "\n" +
                "  flip_horizontal: " + (tile.FlippedHorizontally == true ? 1 : 0) + "\n" +
                "  flip_vertical: " + (tile.FlippedVertically == true ? 1 : 0) + "\n" +
                "}\n";
        }
    }

    if (stringData != "")
        return stringData + animations +
            "margin: 0\n" +
            "extrude_borders: 4\n" +
            "inner_padding: 0\n";
    else
        return "";
}


//--------------------------------------
//
// Return the actual to for tileId
//
//--------------------------------------
function getTileOfId(tiles, id) {

    for (let i = 0; i < tiles.length; i++) {

        if (tiles[i].id == id) {
            return tiles[i];
        }
    }

    return null;
}


//--------------------------------------
//
// Export image collection as an atlas
//
//--------------------------------------
function exportObjects(objectLayer) {

    //let stringData = "return {\n";
    let mapHeight = globalMap.height * globalMap.tileHeight;

    let layerObjs = getProperties(objectLayer, "  ");

    let stringData = "    {\n" +
        "      type = \"objectgroup\",\n" +
        "      id = " + objectLayer.id + ",\n" +
        "      class = \"" + objectLayer.className + "\",\n" +
        "      name = \"" + objectLayer.name + "\",\n" +
        "      width = " + objectLayer.width + ",\n" +
        "      height = " + objectLayer.height + ",\n" +
        "      visible = " + objectLayer.visible + ",\n" +
        (layerObjs != "" ? "      properties = {\n    " + layerObjs + "\n  },\n" : "      properties = {},\n") +
        "      objects = {\n";


    tiled.log("Number of objects: " + objectLayer.objectCount);

    for (let c = 0; c < objectLayer.objectCount; c++) {

        if (objectLayer.objects[c] == null) {
            tiled.log("index: " + c);
            return null;
        }

        //tiled.log("ID: " + objectLayer.objects[c].id);

        if (objectLayer.objects[c] != null) {
            stringData += "        {\n" +
                //"    id = " + object.id + ",\n" +   // Enable for debugging only (find an object that is erroring)
                "          class = \"" + objectLayer.objects[c].className + "\",\n" +
                "          name = \"" + objectLayer.objects[c].name + "\",\n" +
                "          x = " + (objectLayer.objects[c].x) + ",\n" +
                "          y = " + (mapHeight - objectLayer.objects[c].y) + ",\n" +
                "          width = " + objectLayer.objects[c].width + ",\n" +
                "          height = " + objectLayer.objects[c].height + ",\n" +
                "          rotation = " + objectLayer.objects[c].rotation + ",\n" +
                "          flip_x = " + ((objectLayer.objects[c].tileFlippedHorizontally == true) ? 1 : 0) + ",\n" +
                "          flip_y = " + ((objectLayer.objects[c].tileFlippedVertically == true) ? 1 : 0) + ",\n" +
                (objectLayer.objects[c].tile != null ? "          sprite = \"" + FileInfo.fileName(FileInfo.completeBaseName(objectLayer.objects[c].tile.imageFileName)) : "    \"\"\n,") + "\",\n" +
                "          visible = " + objectLayer.objects[c].visible;

            //---------------------------------------
            // Show properties only if the exist
            //---------------------------------------
            let objs = getProperties(objectLayer.objects[c], "        ");
            if (objs != "") {
                stringData += ",\n          properties = {\n" +
                    objs +
                    "\n          }";
            }

            // No unneccessary commas in the Lua code
            if ((c + 1) < objectLayer.objectCount)
                stringData += "\n        },\n";
            else
                stringData += "\n        }\n";
        }
    }

    // Close this segment for good
    stringData += "      }";

    return stringData;
}


//-----------------------------------
//
// Handle exporting the tilemaps
//
//-----------------------------------
function exportTileLayer(currentLayer) {
    let i = 0;
    //let set = tileset + "\n";

    let layerObjs = getProperties(currentLayer, "      ");

    let stringData = "    {\n" +
        "      type = \"tilelayer\",\n" +
        "      id = " + currentLayer.id + ",\n" +
        "      class = \"" + currentLayer.className + "\",\n" +
        "      name = \"" + currentLayer.name + "\",\n" +
        "      width = " + currentLayer.width + ",\n" +
        "      height = " + currentLayer.height + ",\n" +
        "      visible = " + currentLayer.visible + ",\n" +
        (layerObjs != "" ? "      properties = {\n    " + layerObjs + "\n  },\n" : "      properties = {},\n") +
        "      data = {\n        ";

    for (let y = 0; y < currentLayer.height; y++) {
        for (let x = 0; x < currentLayer.width; x++) {

            let currentTile = currentLayer.cellAt(x, y);

            //Only write tile data for tiles map entries that exist
            if (currentTile.tileId != -1) {

                // Get this tile's tileset for comparison.
                // This map should only contain tile entries from the active tileset
                //let cSet = currentLayer.tileAt(x, y).tileset;

                // if (tileset != cSet) {
                //     stringData += "0";
                // }
                // else {
                stringData += (currentTile.tileId + 1);
                //                }
            }
            else {
                stringData += "0";
            }

            if ((y * currentLayer.width + x + 1) < (currentLayer.width * currentLayer.height))
                stringData += ",";

            if ((x + 1) == currentLayer.width) {
                if ((y + 1) < currentLayer.height)
                    stringData += "\n        ";
            }
        }
    }

    return stringData + "\n      }";
}


//-----------------------------------------------
//
// Export properties in a simple form
// Custom Enums / classes only support numbers
//
//-----------------------------------------------
function getProperties(object, spaces) {

    let stringData = "";
    let props = object.properties();

    for (const [key, value] of Object.entries(props)) {

        let str = "";

        //--------------------------------
        // Check for special properties
        //--------------------------------
        if (key == "items") {
            let num = value.value;
            let index = 1;

            if (num > 0) str = spaces + "  " + key + " = {";

            //----------------------------------
            while (num > 0) {
                if (num & 1) {
                    if (index == 1)
                        str += " " + index;
                    else
                        str += ", " + index;
                }

                num >>= 1;
                index++;
            }

            if (str != "") str += " },\n";

            stringData += str; + 1
        }
        else {
            if (typeof value == 'object') {

                // Is it a ref to an object?
                if (value.typeName == null) {

                    if (value.id == null)
                        // String object
                        str = spaces + "  " + key + " = \"" + value + "\",\n";
                    else
                        // Map object
                        str = spaces + "  " + key + " = { id = " + value.id + " },\n";

                } else {
                    str = spaces + "  " + key + " = " + value.value + ",\n";
                }
            }
            else {
                str = spaces + "  " + key + " = " + value + ",\n";
            }

            stringData += str;
        }
    }

    // Remove the last comma set
    if (stringData != "") {
        stringData = stringData.slice(0, -2);// + "\n";
    }

    return stringData;
}


// Register this action to the "Export As" menu selection
tiled.registerMapFormat("TiledToDefoldExport", tiledToDefoldExport);