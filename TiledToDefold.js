/*
 * TiledToDefold.js
 *
 * This extension adds the "Defold files" type to the "Export As" menu,
 * which generates Defold style tilemaps, tilesources and atlases.
 * 
 * The tile maps are generated by finding tilesets and creating individual tilemaps
 * to use tiles from the tileset.
 *
 * Copyright (c) 2022 John Charles
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */

var tiledToDefoldExport = {
    name: "Defold Custom Collection",
    extension: "collection",
    write: processMap
};

let filePath = "";
let fileBaseName = "";
let count = 0;
let collection = "";
let globalMap = null;
let objectLayer = null;
const usedObjs = [];

let collectionHeader =
    "name: \"default\"\n" +
    "scale_along_z: 0\n";


//--------------------------------
//
// Main write function
//
//--------------------------------
function processMap(map, fileName) {

    // Split full filename path into the filename (without extension) and the directory
    fileBaseName = FileInfo.completeBaseName(fileName).replace(/[^a-zA-Z0-9-_]/g, "_");
    filePath = FileInfo.path(fileName) + "/";

    // Replace the ‘/’ characters in the file path for ‘\’ on Windows
    filePath = FileInfo.toNativeSeparators(filePath);

    //Find first tile layer
    let currentLayer;
    count = 0;
    globalMap = map;

    // This is important! set map file's 'Class' to you base directory.
    // IE: c:/defold/MyGame/
    // So if assets or what ever are stored in 'c:/defold/MyGame/assets/...'
    // Then '/assets/...' can be used in the file and directory structure
    fileBaseName = fileBaseName.replace(map.className, '');

    let newPath = filePath + fileBaseName + "/";

    //--------------------------------------
    //
    // Process all Tilemaps first
    //
    //--------------------------------------
    for (let j = 0; j < map.tilesets.length; j++) {

        let tilemapStr = "";
        let z = 0;
        let tileset = map.tilesets[j];
        let iHeader = false;
        let tilesourceFileData = "";
        let fName = null;
        let baseName = null;
        let fPath = null;
        let re = null;

        //-------------------------------------------
        // Tileset MUST be a single image in order 
        // to be considered a tilesource for Defold
        //-------------------------------------------
        if (tileset.image == "") {

            // Atlas creation using a collection of images. Defold uses 2048x2048 max I believe
            tilesourceFileData = processImageCollection(tileset);

            // Write tilesource file
            let tilesource = new TextFile(newPath + tileset.name + ".atlas", TextFile.WriteOnly);
            tilesource.write(tilesourceFileData);
            tilesource.commit();

            continue;
        }
        else {

            re = RegExp(globalMap.className, "ig");
            fName = tileset.image.replace(re, '');
            fPath = FileInfo.path(fileName);
            baseName = FileInfo.completeBaseName(tileset.image);

            // Tilesource data creation
            tilesourceFileData +=
                //"image: \"/main/" + fileBaseName + "/" + tileset.name + ".png\"\n" +
                "image: \"/" + fName + "\"\n" +
                "tile_width: " + tileset.tileWidth + "\n" +
                "tile_height: " + tileset.tileHeight + "\n" +
                "tile_margin: " + tileset.margin + "\n" +
                "tile_spacing: " + tileset.tileSpacing + "\n" +
                "collision: \"/" + fName + "\"\n" +
                "material_tag: \"tile\"\n" +
                "collision_groups: \"ground\"\n" +
                "extrude_borders: 4\n" +
                "inner_padding: 0\n" +
                "sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n";
        }

        // Header showing tilesource file
        let tileMapFileData = "tile_set: \"/" + fPath.replace(re, '') + "/" + fileBaseName + "/" + baseName + ".tilesource\"\n";

        //------------------------------------
        //
        // Loop through the tile layers
        //
        //------------------------------------
        for (let i = 0; i < map.layerCount; ++i) {

            currentLayer = map.layerAt(i);

            //-------------------------------------------
            // Must be a Tile layer, and hasto be visible
            //-------------------------------------------
            if (currentLayer.isTileLayer && currentLayer.visible) {

                let tempMap = "";
                tempMap = exportTileLayer(currentLayer, tileset);

                // Was data stored?
                if (tempMap != "") {

                    // Add the tilesource header once per file
                    if (!iHeader) {
                        tilemapStr += tileMapFileData;
                        iHeader = true;
                    }

                    tilemapStr += "layers {\n";
                    tilemapStr += "  id: \"" + currentLayer.name + "\"\n";
                    tilemapStr += "  z: " + (z / 10000) + "\n";
                    tilemapStr += "  is_visible: " + ((currentLayer.visible) ? 1 : 0) + "\n";
                    tilemapStr += tempMap;
                    tilemapStr += "}\n";
                    // Z-Position
                    z++;
                }
            }
            else if (currentLayer.isObjectLayer && currentLayer.visible) {

                let tempMap = null;
                let count = 0;

                while (tempMap == null && count < 10) {
                    tempMap = exportObjects(currentLayer);
                    count++;
                }

                tiled.log( "Objects: " + ((tempMap == null) ? "null" : "good") + " after " + count + " tries." )

                // Was data stored?
                if (tempMap != "") {

                    // Write the tilemap file
                    let tilemapFile = new TextFile(newPath + currentLayer.name + ".lua", TextFile.WriteOnly);
                    tilemapFile.write(tempMap);
                    tilemapFile.commit();

                    // Z-Position
                    z++;
                    continue;
                }
            }

        }

        //--------------------------------
        // Write source data to disk
        //--------------------------------
        if (tilemapStr != "") {

            // Add the footer
            tilemapStr += "material: \"/builtins/materials/tile_map.material\"\n" +
                "blend_mode: BLEND_MODE_ALPHA\n";


            // Write tilesource file
            let tilesource = new TextFile(newPath + tileset.name + ".tilesource", TextFile.WriteOnly);
            tilesource.write(tilesourceFileData);
            tilesource.commit();

            // Write the tilemap file
            let tilemapFile = new TextFile(newPath + tileset.name + ".tilemap", TextFile.WriteOnly);
            tilemapFile.write(tilemapStr);
            tilemapFile.commit();

            //
            if (collection == "") {
                collection += collectionHeader;
            }

            // Ad the embedded instance
            let re = RegExp(globalMap.className, "ig");
            let fName = tileset.image.replace(re, '');
            let fPath = FileInfo.path(fileName);
            let baseName = FileInfo.completeBaseName(tileset.image);

            // Header showing tilesource file
            let tileMapFileData = fPath.replace(re, '') + "/" + fileBaseName + "/" + baseName + ".tilemap";
            let tname = tileset.name;
            let mapname = tileMapFileData;

            let emdeddedInstance =
                "embedded_instances {\n" +
                "  id: \"tilemaps\"\n" +
                "  data: \"components {\\n\"\n" +
                `  \"   id: \\"${tname}\\"\\n\"\n` +              // Tile map name
                `  \"   component: \\"/${mapname}\\"\\n\"\n` +       // Name of the tilemap file                
                "  \"   position {\\n\"\n" +
                "  \"     x: 0.0\\n\"\n" +
                "  \"     y: 0.0\\n\"\n" +
                "  \"     z: 0.0\\n\"\n" +
                "  \"  }\\n\"\n" +
                "  \"  rotation {\\n\"\n" +
                "  \"     x: 0.0\\n\"\n" +
                "  \"     y: 0.0\\n\"\n" +
                "  \"     z: 0.0\\n\"\n" +
                "  \"     w: 1.0\\n\"\n" +
                "  \"  }\\n\"\n" +
                "  \"}\\n\"\n" +
                "  \"\"\n" +

                "  position {\n" +
                "    x: 0\n" +
                "    y: 0\n" +
                "    z: 0.0\n" +
                "  }\n" +
                "  rotation {\n" +
                "    x: 0.0\n" +
                "    y: 0.0\n" +
                "    z: 0.0\n" +
                "    w: 1.0\n" +
                "  }\n" +
                "  scale3 {\n" +
                "    x: 1.0\n" +
                "    y: 1.0\n" +
                "    z: 1.0\n" +
                "  }\n" +
                "}";

            // Write tilesource file
            let collectionFile = new TextFile(newPath + fileBaseName + ".collection", TextFile.WriteOnly);
            collectionFile.write(collectionHeader + emdeddedInstance);
            collectionFile.commit();
        }
        count++;
    }
}



//-----------------------------------
//
// Handle exporting the tilemaps
//
//-----------------------------------
function exportTileLayer(currentLayer, tileset) {
    let i = 0;
    let stringData = "";
    let set = tileset + "\n";


    for (let x = 0; x < currentLayer.width; x++) {
        for (let y = 0; y < currentLayer.height; y++) {

            let currentTile = currentLayer.cellAt(x, y);

            //Only write tile data for tiles map entries that exist
            if (currentTile.tileId != -1) {

                // Get this tile's tileset for comparison.
                // This map should only contain tile entries from the active tileset
                let cSet = currentLayer.tileAt(x, y).tileset;

                if (tileset != cSet)
                    continue;

                stringData += "  cell {\n";
                stringData += "    x: " + x + "\n";
                stringData += "    y: " + (currentLayer.height - y - 1) + "\n";
                stringData += "    tile: " + currentTile.tileId + "\n";

                stringData += "    h_flip: " + ((currentTile.flippedHorizontally) ? 1 : 0) + "\n";
                stringData += "    v_flip:  " + ((currentTile.flippedVertically) ? 1 : 0) + "\n";

                //
                stringData += "    rotate90: " + 0 + "\n";
                stringData += "  }\n";
            }
        }
    }

    return stringData;
}


//--------------------------------------
//
// Export image collection as an atlas
//
//--------------------------------------
function processImageCollection(tileset) {

    let stringData = "";
    let animations = "";
    let duration = 0;
    let re = RegExp(globalMap.className, "ig");

    for (let c = 0; c < tileset.tiles.length; c++) {

        let tile = tileset.tiles[c];

        if (tile == null)
            continue;

        let fName = tile.imageFileName.replace(re, '');

        //Header info
        stringData += "images {\n" +
            "  image: \"/" + fName + "\"" + "\n" +
            "  sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n" +
            "}\n";


        // Save animation data should it exist
        if (tile.animated == true) {

            animations += "animations {\n" +
                "  id: \"anim-" + c + "\"\n";

            duration = 0;

            for (let i = 0; i < tile.frames.length; i++) {
                let frame = tile.frames[i];

                let realTile = getTileOfId(tileset.tiles, frame.tileId);

                if (realTile != null) {
                    // Add all durations together
                    duration += frame.duration;

                    animations += "  images {\n" +
                        "    image: \"/" + realTile.imageFileName + "\"" + "\n" +
                        "    sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n" +
                        "  }\n";
                }
            }

            // Calcution an average of time per frame. 'Duration / frames' = based milliseconds for fps calculation
            //  fps = (1000 / Duration_base)
            duration /= tile.frames.length;

            animations += "  playback: PLAYBACK_LOOP_FORWARD\n" +
                "  fps: " + (1000 / duration) + "\n" +
                "  flip_horizontal: " + (tile.FlippedHorizontally == true ? 1 : 0) + "\n" +
                "  flip_vertical: " + (tile.FlippedVertically == true ? 1 : 0) + "\n" +
                "}\n";
        }
    }

    if (stringData != "")
        return stringData + animations +
            "margin: 0\n" +
            "extrude_borders: 4\n" +
            "inner_padding: 0\n";
    else
        return "";
}


//--------------------------------------
//
// Return the actual to for tileId
//
//--------------------------------------
function getTileOfId(tiles, id) {

    for (let i = 0; i < tiles.length; i++) {

        if (tiles[i].id == id) {
            return tiles[i];
        }
    }

    return null;
}


//--------------------------------------
//
// Export image collection as an atlas
//
//--------------------------------------
function exportObjects(objectLayer) {

    let stringData = "return {\n";
    let mapHeight = globalMap.height * globalMap.tileHeight;

    tiled.log("Number of objects: " + objectLayer.objectCount);

    for (let c = 0; c < objectLayer.objectCount; c++) {

        if (objectLayer.objects[c] == null) {            
            tiled.log("index: " + c);
            return null;
        }

        tiled.log("ID: " + objectLayer.objects[c].id);

        if (objectLayer.objects[c] != null) 
        {
            stringData += "  {\n" +
                //"    id = " + object.id + ",\n" +   // Enable for debugging only (find an object that is erroring)
                "    class = \"" + objectLayer.objects[c].className + "\",\n" +
                "    name = \"" + objectLayer.objects[c].name + "\",\n" +
                "    x = " + (objectLayer.objects[c].x) + ",\n" +
                "    y = " + (mapHeight - objectLayer.objects[c].y) + ",\n" +
                "    width = " + objectLayer.objects[c].width + ",\n" +
                "    height = " + objectLayer.objects[c].height + ",\n" +
                "    rotation = " + objectLayer.objects[c].rotation + ",\n" +
                "    flip_x = " + ((objectLayer.objects[c].tileFlippedHorizontally == true) ? 1 : 0) + ",\n" +
                "    flip_y = " + ((objectLayer.objects[c].tileFlippedVertically == true) ? 1 : 0) + ",\n" +
                (objectLayer.objects[c].tile != null ? "    sprite = \"" + FileInfo.fileName(FileInfo.completeBaseName(objectLayer.objects[c].tile.imageFileName)) : "    \"\"\n,") + "\",\n" +
                "    visible = " + objectLayer.objects[c].visible;

            //---------------------------------------
            // Show properties only if the exist
            //---------------------------------------
            let objs = getProperties(objectLayer.objects[c], "    ");
            if (objs != "") {
                stringData += ",\n    properties = {\n" +
                    objs +
                    "\n    }";
            }

            // No unneccessary commas in the Lua code
            if ((c + 1) < objectLayer.objectCount)
                stringData += "\n  },\n";
            else
                stringData += "\n  }\n";
        }
    }

    // Close this segment for good
    stringData += "}\n";

    return stringData;
}


//-----------------------------------------------
//
// Export properties in a simple form
// Custom Enums / classes only support numbers
//
//-----------------------------------------------
function getProperties(object, spaces) {

    let stringData = "";
    let props = object.properties();

    for (const [key, value] of Object.entries(props)) {

        let str = "";

        //--------------------------------
        // Check for special properties
        //--------------------------------
        if (key == "items") {
            let num = value.value;
            let index = 1;

            if (num > 0) str = spaces + "  " + key + " = {";
            
            //----------------------------------
            while (num > 0) {
                if (num & 1) {
                    if (index == 1)
                        str += " " + index;
                    else
                        str += ", " + index;
                }

                num >>= 1;
                index++;
            }

            if (str != "") str += " },\n";

            stringData += str;
        }
        else {
            if (typeof value == 'object') {

                // Is it a ref to an object?
                if (value.typeName == null) {

                    if (value.id == null)
                        // String object
                        str = spaces + "  " + key + " = \"" + value + "\",\n";
                    else
                        // Map object
                        str = spaces + "  " + key + " = { id = " + value.id + " },\n";

                } else {
                    str = spaces + "  " + key + " = " + value.value + ",\n";
                }
            }
            else {
                str = spaces + "  " + key + " = " + value + ",\n";
            }

            stringData += str;
        }
    }

    // Remove the last comma set
    if (stringData != "") {
        stringData = stringData.slice(0, -2);// + "\n";
    }

    return stringData;
}


// Register this action to the "Export As" menu selection
tiled.registerMapFormat("TiledToDefoldExport", tiledToDefoldExport);