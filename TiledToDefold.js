/*
 * TiledToDefold.js
 *
 * This extension adds the "Defold files" type to the "Export As" menu,
 * which generates Defold style tilemaps, tilesources and atlases.
 * 
 * The tile maps are generated by finding tilesets and creating individual tilemaps
 * to use tiles from the tileset.
 *
 * Copyright (c) 2022 John Charles
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */

var tiledToDefoldExport = {
    name: "Defold files",
    extension: "tilemap",
    write: processMap
};

let filePath = "";
let fileBaseName = "";
let count = 0;
let y = 0;

//--------------------------------
//
// Main write function
//
//--------------------------------
function processMap(map, fileName) {

    // Split full filename path into the filename (without extension) and the directory
    fileBaseName = FileInfo.completeBaseName(fileName).replace(/[^a-zA-Z0-9-_]/g, "_");
    filePath = FileInfo.path(fileName) + "/";

    // Replace the ‘/’ characters in the file path for ‘\’ on Windows
    filePath = FileInfo.toNativeSeparators(filePath);

    //Find first tile layer
    let currentLayer;
    count = 0;

    //--------------------------------------
    //
    // Process all Tilemaps first
    //
    //--------------------------------------
    for (let j = 0; j < map.tilesets.length; j++) {

        let tilemapStr = "";
        let z = 0;
        let tileset = map.tilesets[j];
        let iHeader = false;
        let tilesourceFileData = "";

        //-------------------------------------------
        // Tileset MUST be a single image in order 
        // to be considered a tilesource for Defold
        //-------------------------------------------
        if (tileset.image == "") {

            // Atlas creation using acollection of images. Defold uses 2048x2048 max I believe
            tilesourceFileData = processImageCollection(tileset);

            // Write tilesource file
            let tilesource = new TextFile(filePath + tileset.name + ".atlas", TextFile.WriteOnly);
            tilesource.write(tilesourceFileData);
            tilesource.commit();
            console.log("Atlas file exported to " + filePath + tileset.name + ".atlas");

            continue;
        }
        else {
            // Tilesource data creation
            tilesourceFileData +=
                "image: \"/tilesources/" + tileset.name + ".png\"\n" +
                "tile_width: " + tileset.tileWidth + "\n" +
                "tile_height: " + tileset.tileHeight + "\n" +
                "tile_margin: " + tileset.margin + "\n" +
                "tile_spacing: " + tileset.tileSpacing + "\n" +
                "collision: \"/tilesources/" + tileset.name + ".png\"\n" +
                "material_tag: \"tile\"\n" +
                "collision_groups: \"ground\"\n" +
                "extrude_borders: 2\n" +
                "inner_padding: 0\n" +
                "sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n";
        }

        // Header showing tilesource file
        let tileMapFileData = "tile_set: \"/tilemaps/" + tileset.name + ".tilesource\"\n";

        //------------------------------------
        //
        // Loop through the tile layers
        //
        //------------------------------------
        for (let i = 0; i < map.layerCount; ++i) {

            currentLayer = map.layerAt(i);

            //-------------------------------------------
            // Must be aTile layer, and hasto be visible
            //-------------------------------------------
            if (currentLayer.isTileLayer && currentLayer.visible) {

                let tempMap = "";
                tempMap = exportTileLayer(currentLayer, tileset);

                // Was data stored?
                if (tempMap != "") {

                    // Add the tilesource header once per file
                    if (!iHeader) {
                        tilemapStr += tileMapFileData;
                        iHeader = true;
                    }

                    tilemapStr += "layers {\n";
                    tilemapStr += "  id: \"" + currentLayer.name + "\"\n";
                    tilemapStr += "  z: " + (z / 10000) + "\n";
                    tilemapStr += "  is_visible: " + ((currentLayer.visible) ? 1 : 0) + "\n";
                    tilemapStr += tempMap;
                    tilemapStr += "}\n";

                    // Z-Position
                    z++;
                }
            }
            else if (currentLayer.isObjectLayer && currentLayer.visible) {

                let tempMap = "";

                tempMap = exportObjects(currentLayer);

                // Was data stored?
                if (tempMap != "") {

                    // Write the tilemap file
                    let tilemapFile = new TextFile(filePath + currentLayer.name + ".lua", TextFile.WriteOnly);
                    tilemapFile.write(tempMap);
                    tilemapFile.commit();
                    console.log("Tilemap file exported to " + filePath + currentLayer.name + ".lua");

                    // Z-Position
                    z++;
                    continue;
                }
            }

        }

        //--------------------------------
        // Write source data to disk
        //--------------------------------
        if (tilemapStr != "") {
            // Write tilesource file
            let tilesource = new TextFile(filePath + tileset.name + ".tilesource", TextFile.WriteOnly);
            tilesource.write(tilesourceFileData);
            tilesource.commit();
            console.log("Tilesource file exported to " + filePath + tileset.name + ".tilesource");

            // Write the tilemap file
            let tilemapFile = new TextFile(filePath + fileBaseName + "-" + count + ".tilemap", TextFile.WriteOnly);
            tilemapFile.write(tilemapStr);
            tilemapFile.commit();
            console.log("Tilemap file exported to " + filePath + fileBaseName + ".tilemap");
        }
        count++;
    }
}

//-----------------------------------
//
// Handle exporting the tilemaps
//
//-----------------------------------
function exportTileLayer(currentLayer, tileset) {
    let i = 0;
    let stringData = "";
    let set = tileset + "\n";


    for (let y = 0; y < currentLayer.height; y++) {
        for (let x = 0; x < currentLayer.width; x++) {

            let currentTile = currentLayer.cellAt(x, y);

            //Only write tile data for tiles map entries that exist
            if (currentTile.tileId != -1) {

                // Get this tile's tileset for comparison.
                // This map should only contain tile entries from the active tileset
                let cSet = currentLayer.tileAt(x, y).tileset;

                if (tileset != cSet)
                    continue;

                stringData += "  cell {\n";
                stringData += "    x: " + x + "\n";
                stringData += "    y: " + y + "\n";
                stringData += "    tile: " + currentTile.tileId + "\n";

                stringData += "    h_flip: " + ((currentTile.flippedHorizontally) ? 1 : 0) + "\n";
                stringData += "    v_flip:  " + ((currentTile.flippedVertically) ? 1 : 0) + "\n";

                //
                stringData += "    rotate90: " + 0 + "\n";
                stringData += "  }\n";
            }
        }
    }

    return stringData;
}


//--------------------------------------
//
// Export image collection as an atlas
//
//--------------------------------------
function processImageCollection(tileset) {

    let stringData = "";
    let animations = "";
    let duration = 0;

    for (let c = 0; c < tileset.tiles.length; c++) {

        let tile = tileset.tiles[c];

        //Header info
        stringData += "images {\n" +
            "  image: \"/images/" + tileset.name + "/" + FileInfo.fileName(tile.imageFileName) + "\"" + "\n" +
            "  sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n" +
            "}\n";

        // Save animation data should it exist
        if (tile.animated == true) {

            animations += "animations {\n" +
                "  id: \"anim-" + c + "\"\n";

            duration = 0;

            for (let i = 0; i < tile.frames.length; i++) {
                let frame = tile.frames[i];

                // Add all durations together
                duration += frame.duration;

                animations += "  images {\n" +
                    "    image: \"/images/" + tileset.name + "/" + FileInfo.fileName(tileset.tiles[frame.tileId].imageFileName) + "\"" + "\n" +
                    "    sprite_trim_mode: SPRITE_TRIM_MODE_OFF\n" +
                    "  }\n";
            }

            // Calcution an average of time per frame. 'Duration / frames' = based milliseconds for fps calculation
            //  fps = (1000 / Duration_base)
            duration /= tile.frames.length;

            animations += "  playback: PLAYBACK_LOOP_FORWARD\n" +
                "  fps: " + (1000 / duration) + "\n" +
                "  flip_horizontal: " + (tile.FlippedHorizontally == true ? 1 : 0) + "\n" +
                "  flip_vertical: " + (tile.FlippedVertically == true ? 1 : 0) + "\n" +
                "}\n";
        }
    }

    return stringData + animations;
}


//--------------------------------------
//
// Export image collection as an atlas
//
//--------------------------------------
function exportObjects(objectLayer) {

    let stringData = "return {\n";

    for (let c = 0; c < objectLayer.objectCount; c++) {

        let object = objectLayer.objects[c];

        stringData += "  {\n" +
            "    id = " + object.id + ",\n" +
            "    class = \"" + object.className + "\",\n" +
            "    name = \"" + object.name + "\",\n" +
            "    x = " + object.x + ",\n" +
            "    y = " + object.y + ",\n" +
            "    width = " + object.width + ",\n" +
            "    height = " + object.height + ",\n" +
            "    rotation = " + object.rotation + ",\n" +
            (object.tile != null ? "    source = \"/images/atlas/" + object.tile.tileset.name + ".atlas\",\n" : "    \"\"\n,") +
            (object.tile != null ? "    image = \"" + FileInfo.fileName(FileInfo.completeBaseName(object.tile.imageFileName)) : "    \"\"\n,") + "\",\n" +
            "    visible = " + object.visible;

        //---------------------------------------
        // Show properties only if the exist
        //---------------------------------------
        let objs = getProperties(object, "    ");
        if (objs != "") {
            stringData += ",\n    properties = {\n" +
                objs +
                "\n    }";
        }

        // No unneccessary commas in the Lua code
        if ((c + 1) < objectLayer.objectCount)
            stringData += "\n  },\n";
        else
            stringData += "\n  }\n";
    }

    // Close this segment for good
    stringData += "}\n";

    return stringData;
}


//-----------------------------------------------
//
// Export properties in a simple form
// Custom Enums / classes only support numbers
//
//-----------------------------------------------
function getProperties(object, spaces) {

    let stringData = "";
    let props = object.properties();

    for (const [key, value] of Object.entries(props)) {

        let str = "";

        //--------------------------------
        // Check for special properties
        //--------------------------------
        if (key == "items") {
            let num = value.value;
            let index = 1;

            if (num > 0)
                //str = spaces + "  [\"" + key + "\"] = {";
                str = spaces + "  " + key + " = {";
            //

            while (num > 0) {
                if (num & 1) {
                    if (index == 1)
                        str += " " + index;
                    else
                        str += ", " + index;
                }

                num >>= 1;
                index++;
            }

            if (str != "") str += " },\n";

            tiled.log(str);
            stringData += str;
        }
        else {
            if (typeof value == 'object') {

                // Is it a ref to an object?
                if (value.typeName == null) {
                    //tiled.log(typeof value + " " + value.id + " " + value.x + " " + value.type + " " + value.constructor.type);

                    if (value.id == null)
                        // String object
                        //str = spaces + "  [\"" + key + "\"] = \"" + value + "\",\n";
                        str = spaces + "  " + key + " = \"" + value + "\",\n";
                    else
                        // Map object
                        //str = spaces + "  [\"" + key + "\"] = { id = " + value.id + " },\n";
                        str = spaces + "  " + key + " = { id = " + value.id + " },\n";

                } else {
                    //str = spaces + "  [\"" + key + "\"] = " + value.value + ",\n";
                    str = spaces + "  " + key + " = " + value.value + ",\n";
                }
            }
            else {
                //str = spaces + "  [\"" + key + "\"] = " + value + ",\n";
                str = spaces + "  " + key + " = " + value + ",\n";
            }

            stringData += str;
        }
    }

    // Remove the last comma set
    if (stringData != "") {
        stringData = stringData.slice(0, -2);// + "\n";
        tiled.log(stringData);
    }

    return stringData;
}


// Register this action to the "Export As" menu selection
tiled.registerMapFormat("TiledToDefoldExport", tiledToDefoldExport)
